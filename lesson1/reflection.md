# Рефлексия

1. Получить информацию о всех гномах, которые входят в какой-либо отряд, вместе с информацией об их отрядах.

```sql
SELECT 
       D.name AS DwarfName,
       D.profession AS Profession,
       S.name AS SquadName,
       S.mission AS Mission
   FROM 
       Dwarves D
   JOIN 
       Squads S
   ON 
       D.squad_id = S.squad_id;
```
При анализе условно эталонного решения я допустил несколько ошибок:
- Названия таблиц брал с маленькой буквы.
- Не использовал алиасы, хотя с помощью них можно сделать решение более ясным.
- Вывел не конкретную информацию, а все атрибуты сущности Dwarves.
В целом решение было правильное, но необходимо более внимательно читать условия, а также для себя понял, как именно необходимо понимать те или иные требования в задаче.

Решение после рефлексии:

```sql
SELECT
    D.name AS DwarfName,
    D.age AS DwarfAge,
    D.profession AS DwarfProfession,
    S.name AS SquadName,
    S.mission AS SquadMission,
        FROM Dwarves D JOIN Squads S
        ON D.squad_id = S.squad_id;
```

2. Найти всех гномов с профессией "miner", которые не состоят ни в одном отряде.

```sql
SELECT 
       name,
       age
   FROM 
       Dwarves
   WHERE 
       profession = 'miner' AND squad_id IS NULL;
```

При анализе условно эталонного решения я допустил несколько ошибок:
- Названия таблиц брал с маленькой буквы.
- Не использовал алиасы, хотя с помощью них можно сделать решение более ясным.
- Вывел не конкретную информацию, а все атрибуты сущности Dwarves.
В целом решение было правильное, но необходимо более внимательно читать условия, а также для себя понял, как именно необходимо понимать те или иные требования в задаче. Также понял, что при использовании только одной таблицы лучше не использовать алиасы, а также синтаксис доступа к атрибутам через точку, ведь проще и яснее будет их просто перечислить, так как отношение одно.

Решение после рефлексии:

```sql
SELECT name, age FROM Dwarves
    WHERE squad_id IS NULL AND profession = 'miner';
```

3. Получить все задачи с наивысшим приоритетом, которые находятся в статусе "pending".

```sql
SELECT 
       task_id,
       description,
       assigned_to
   FROM 
       Tasks
   WHERE 
       priority = (SELECT MAX(priority) FROM Tasks WHERE status = 'pending') 
       AND status = 'pending';
```

При анализе условно эталонного решения я допустил несколько ошибок:
- Названия таблиц брал с маленькой буквы.
- Вывел не конкретную информацию, а все атрибуты сущности Tasks.
- Результат моего запроса будет неверным, так как приоритетность задач я выбираю из всего множества, а не из множества задач, статус которых находится в `'pending'`, соответственно задача будет решена неверно, хоть и направление решения было правильным.

Задача решена неверно, поскольку приоритетность заданий выбиралась по всем статусам, а не по одному - `'pending'`. Необходимо быть более внимательным при анализе задачи, если в задаче стоит длинное и не простое условие, стоит разбить задачу на несколько небольших с простыми условиями и решить их по отдельности, а затем компоновать в полноценное решение, таким образом получится не допускать таких ошибок.

Решение после рефлексии:

```sql
SELECT task_id, description, assigned_to FROM Tasks

WHERE priority = (

	SELECT MAX(priority) FROM Tasks

	WHERE status = 'pending'

) AND status = 'pending';
```


4. Для каждого гнома, который владеет хотя бы одним предметом, получить количество предметов, которыми он владеет.

```sql
SELECT 
	D.name AS DwarfName, 
	D.profession AS Profession, 
	COUNT(I.item_id) AS ItemCount 
	FROM 
		Dwarves D 
	JOIN 
		Items I
	ON 
		D.dwarf_id = I.owner_id 
	GROUP BY 
		D.dwarf_id, D.name, D.profession;
```

При анализе условно эталонного решения я допустил несколько ошибок:
- Названия таблиц брал с маленькой буквы.
- Вывел не конкретную информацию, а лишь некоторые атрибуты.
- Не использовал алиасы, хотя с помощью них можно сделать решение более ясным.
- Не использовал группировку по атрибутам.
В целом решение не совсем верное, так как я не группировал записи, из-за этого результат будет неверным, также для себя отметил в очередной раз, что если в запросе участвует больше одной сущности(таблицы), то необходимо использовать алиасы для выразительности и ясности кода, так решение выглядит более понятным. Также необходимо использовать группировку в тех случаях, когда используются агрегатные функции для записей таблицы, так как необходимо выделять группу, по которой будут агрегироваться данные (без группировки данных будут обработаны все найденные строки, без их обработки).

Решение после рефлексии:

```sql
SELECT
    D.name AS DwarfName,
    D.profession AS DwarfProfession,
    COUNT(I.item_id) AS ItemsCount
FROM
    Dwarves D JOIN Items I
    ON D.dwarf_id = I.owner_id
    GROUP BY D.name, D.profession;
```

5. Получить список всех отрядов и количество гномов в каждом отряде. Также включите в выдачу отряды без гномов.

```sql
SELECT 
	S.squad_id, 
	S.name AS SquadName, 
	COUNT(D.dwarf_id) AS NumberOfDwarves 
FROM 
	Squads S 
LEFT JOIN 
	Dwarves D 
ON 
	S.squad_id = D.squad_id 
GROUP BY 
	S.squad_id, S.name;
```

При анализе условно эталонного решения я допустил несколько ошибок:
- Названия таблиц брал с маленькой буквы.
- Вывел не конкретную информацию, а лишь некоторые атрибуты.
- Не использовал алиасы, хотя с помощью них можно сделать решение более ясным.
- Не использовал группировку по атрибутам.
В целом решение не совсем верное, так как я не группировал записи, из-за этого результат будет неверным, также для себя отметил в очередной раз, что если в запросе участвует больше одной сущности(таблицы), то необходимо использовать алиасы для выразительности и ясности кода, так решение выглядит более понятным. Также необходимо использовать группировку в тех случаях, когда используются агрегатные функции для записей таблицы, так как необходимо выделять группу, по которой будут агрегироваться данные (без группировки данных будут обработаны все найденные строки, без их обработки).

Решение после рефлексии:

```sql
SELECT
    S.squad_id AS SquadID,
    S.name AS SquadName,
    COUNT(D.dwarf_id) AS CountDwarfs
FROM
    Squad S LEFT JOIN Dwarves D
    ON D.squad_id = S.squad_id
GROUP BY S.squad_id, S.name;
```

6. Получить список профессий с наибольшим количеством незавершённых задач ("pending" и "in_progress") у гномов этих профессий.

```sql
SELECT 
	D.profession, 
	COUNT(T.task_id) AS UnfinishedTasksCount 
FROM 
	Dwarves D 
JOIN 
	Tasks T 
ON 
	D.dwarf_id = T.assigned_to 
WHERE 
	T.status IN ('pending', 'in_progress') 
GROUP BY D.profession 
ORDER BY UnfinishedTasksCount DESC;
```

При анализе условно эталонного решения я допустил несколько ошибок:
- Названия таблиц брал с маленькой буквы.
- Вывел не конкретную информацию, а лишь некоторые атрибуты.
- Не использовал алиасы, хотя с помощью них можно сделать решение более ясным.
- Не использовал группировку по атрибутам.
Задачу понял не совсем верно, хотя правильное решение на задачу кроется в подзапросе. Я намудрил с решением задачи, оказалось все намного проще. Необходимо было вывести список профессий вместе с количеством в порядке убывания.

Решение после рефлексии:

```sql
SELECT
    D.profession AS DwarfProfession,
    COUNT(T.task_id) AS CountUnfinishedTasks
FROM
    Dwarves D JOIN Tasks T
    ON D.dwarf_id = T.assigned_to
WHERE
    T.status IN ('pending', 'in_progress')
GROUP BY D.profession
ORDER BY CountUnfinishedTasks DESC;
```

7. Для каждого типа предметов узнать средний возраст гномов, владеющих этими предметами.

```sql
SELECT 
	I.type AS ItemType, 
	AVG(D.age) AS AverageAge 
FROM 
	Items I 
JOIN 
	Dwarves D 
ON 
	I.owner_id = D.dwarf_id 
GROUP BY I.type;
```
При анализе условно эталонного решения я допустил несколько ошибок:
- Названия таблиц брал с маленькой буквы.
- Вывел не конкретную информацию, а лишь некоторые атрибуты.
- Не использовал алиасы, хотя с помощью них можно сделать решение более ясным.
- Не использовал группировку по атрибутам.
В целом решение задач было верное за исключением группировки данных, из-за которой будет получена некорректная информация после выполнения запроса.

Решение после рефлексии:

```sql
SELECT
    I.type AS ItemType,
    AVG(D.age) AS AverageDwarfsAge
FROM
    Dwarves D JOIN Items I
    ON D.dwarf_id = I.owner_id
GROUP BY I.type;
```

8. Найти всех гномов старше среднего возраста (по всем гномам в базе), которые не владеют никакими предметами.

```sql
SELECT 
	D.name, 
	D.age, 
	D.profession 
FROM 
	Dwarves D 
WHERE 
	D.age > (
	SELECT AVG(age) FROM Dwarves
) 
AND 
	D.dwarf_id NOT IN (
	SELECT owner_id FROM Items
);
```

При анализе условно эталонного решения я допустил несколько ошибок:
- Названия таблиц брал с маленькой буквы.
- Вывел не конкретную информацию, а лишь некоторые атрибуты.
- Не использовал алиасы, хотя с помощью них можно сделать решение более ясным.
- По невнимательности неверно использовал конструкцию `LEFT JOIN`, которая здесь и не нужна
Задача решена неверно, поскольку был использован `LEFT JOIN` с таблицей `Items` неверно, где мы соединяли инструменты с гномами, а не наоборот, из-за этого результат будет неверным и некорректным, вместо этого необходимо было использовать подзапросы.

Решение после рефлексии:

```sql
SELECT
    D.name,
    D.age,
    D.profession
FROM
    Dwarves D
WHERE
    D.age > (
        SELECT AVG(age) FROM Dwarves
    )
AND D.dwarf_id NOT IN (
    SELECT owner_id FROM Items
);
```
